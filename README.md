# DisciplesOfHeroes
Technical demo project for the portfolio. Inspired by such series as Disciples and Heroes of Might and Magic, but with simplified visuals and game mechanics. 
Done with Qt framework for UI and rendering and pure C++ with STL for the rest.
Note: all textures are found on the Internet and not intended for commercial use.

## Краткое описание архитектуры проекта

### Ключевые модули
- UserInterface
  - Отвечает за обработку виджетов пользовательского интерфейса и рендер графических составляющих. Является единственным модулем, использующим библиотеку Qt.
- GameLogic
  - Высокоуровневый управляющий модуль, определяющий алгоритм работы программы при различных событиях (перемещение персонажа, атака вражеского юнита и т.д.). При этом не описывает реализацию конкретных процессов (например, расчет урона), а является связкой между более низкоуровневыми модулями.
- MapManager
  - Хранит информацию о тайлах глобальной карты и расположенных на них абстрактных объектах (герои, города, ресурсы и т.д.). Предоставляет доступ к данной информации по индексу тайла карты. Предоставляет интерфейс для изменения, загрузки и сохранения карт.
- PlayersManager
  - Предоставляет интерфейс создания игроков и хранит их экземляры. Формирует очередь хода игроков.
- HeroesManager
  - Содержит пул героев (персонажей), предоставляет доступ к ним.
- TownsManager:
  - Содержит пул городов, предоставляет доступ к ним, управляет еженедельным приростом юнитов в городах.
- UnitFactory
  - Предоставляет интерфейс создания новым юнитов. Создание выполняется с помощью абстрактной фабрики.
- EventHandler
  - Обработчик очереди событий. При детектированиии определенного события вызывает соответствующие методы игровой логики и интерфейса. Генерация событий может выполняться любым другим модулем.
- BattleManager
  - Логика процесса битвы. Вычисляет очередь хода юнитов, обрабатывает процедуры атаки, детектирует окончание битвы, формирует обратную связь для отображения результатов действий на интерфейсе. Факт начачал битвы и участвующих персонажей определяет игровая логика.
- Hero
  - Содержит информацию об имени, расе, армии, характеристиках (параметры передвижения, радиус обзора и т.д.) персонажа, описывает способность перемещения по той или иной поверхности карты. Описывает логику взаимодействия с другими персонажами (битва с вражеским персонажем, обмен с дружественным).
- Town
  - Описывает тип и имя города, хранит доступных для найма юнитов, управляет их приростом. Описывает логику взаимодействия с персонажами (осада, переход в гарнизон, найм юнитов и т.д.). 
- Unit
  - Базовый класс юнитов с описанием общей логики взаимодействия (атака/лечение), параметрами (размер группы, раса, уровень и т.д.) и интерфейсом доступа. Наследуется каждым конкретным типом юнитов для определения характеристик и (при наличии особенностей) переопределения методов взаимодействия (например, самолечение вампира при успешной нанесении урона).
- Army
  - Совокупность экземпляров юнитов, описывает их взаимное расположение в армии, предоставляет интерфейс для перестановки и получения информации о юните на конкретной позиции или о позиции конкретного юнита.

### Инициализация модулей и их взаимодействие друг с другом
Все ключевые модули унаследованны от абстрактных интерфейсов. Создание высокоуровневых модулей (GameLogic, MapManager, HeroesManager и пр.) выполняется в main.cpp, там же производится инициализация требуемыми указателями на интерфейсы этих модулей. Создание более низкоуровневых модулей (Hero, Unit и т.д.) выполняется в соответствующих им высокоуровневых управляющих модулях (HeroesManager, UnitFactory и т.д.), которые являются единственными носителями информации о конкретных типах создаваемых объектов, остальные участки программы имеют доступ только к их интерфейсам.

Пример взаимодействия между модулями:
  - Пользователь выбирает персонажа на глобальной карте. UserInterface детектирует нажатие клавишы мыши, определяет координаты тайла, над которым расположен курсор, и запрашивает информацию о нем через указатель на интерфейс IMapManager. В случае существования на тайле объекта типа ObjectType::Hero, имя этого объекта передается в метод обработки выделения персонажа через интерфейс игровой логики IGameLogic. В классе GameLogic выполняется запрос на получение данных о персонаже с переданным именем у текущего игрока через интерфейс IPlayer и, в случае успеха, фиксирует указатель на интерфейс персонажа IHero. При следующем цикле отрисовки глабольной карты, класс UserInterface через интерфейс игровой логики выполнит запрос на информацию о выделенном персонаже. В случае, если такая информация есть, при отрисовке соответствующего персонажа будет применена особая индикация.

### Логика взаимодействия объектов на глобальной карте
Все объекты, располагаемые на карте и предполагающие то или иное взаимодействие с персонажем (ресурсы, другие персонажи и т.д.), унаследованы от интерфейса IInteractableObject, ключевым методом которого является IInteractableObject::interact. Каждый класс определяет собственный алгоритм действий при взаимодействии с ним персонажа. Это позволяет не описывать каждый возможный вариант взаимодействия в игровой логике, вместо этого будет вызван переопределенный метод объекта на тайле через интерфейс IInteractableObject.

### Логика обработчика событий
Обработчик событий занимается постоянным разбором очереди событий. В один момент времени может быть активно только одно событие, поэтому при наличии в очереди нескольких - остальные будут ожидать завершения текущего. Факт завершения события определяется, в зависимости от типа события, либо самим обработчиком, либо некоторым другим модулем (например, игровой логикой). При завершении события обработчиком выполняется, при наличии, функция окончания событя, сформированная генерирующим событие модулем в виде лямбда-функции. Это позволяет использовать одни и те же типы событий, но при этом выполнять разные действия при их завершении. Например, окончание битвы двух персонажей, встретившихся на открытой местности, сопровождается определением проигравшего героя и его уничтожением, в то время как осада замка может сопровождаться сменой владельца в случае победы атакующего. При этом в обоих случаях применяется одно и то же событие начала битвы.
